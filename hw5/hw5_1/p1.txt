In the third instruction, we need r3 and r1, but r1 is in MEMWB so, we forward this to the execute stage, and r3 is in EXMEM so we forward this also to execute stage. r1 and r3 are available for execution of r2 before even r1 and r3 are written back because forwarding is implemented. So instruction three is not stalled at all. Optimization is done. Even with the forth instruction, r2 is forwarded from EXMEM to execution stage for forth instruction. For fifth instruction, r2 value is forwarded from MEMWB to execution. Now in sixth instruction, a tricky thing happens, the r2 gets overwritten by the value from third instruction but since it is still overwritten by value in instruction 5, for sixth instruction we forward the new value of r2 in EXMEM to execution stage. For seventh instruction, r2 value is forwarded from MEMWB. For instruction eight, the value stored in r2 is read, since there is no new value for r2. 
For inst 9, r3 from previous instruction is forwarded from EXMEM to the writedata output for execution stage of this instruction.
For instruction 11, r7 which is overwritten in previous instruction is used in calculating memory address, it is forwarded from EXMEM to execution stage to calculate address.
For inst 13, since r5 is overwritten in previous inst, so the new value is forwarded from writeback stage of previous inst to dataIn of memory stage of new inst.